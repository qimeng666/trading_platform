{"ast":null,"code":"define([\"./core\", \"./core/toType\", \"./var/isFunction\", \"./var/rnothtmlwhite\"], function (jQuery, toType, isFunction, rnothtmlwhite) {\n  \"use strict\"; // Convert String-formatted options into Object-formatted ones\n\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value for non-forgettable lists\n    memory,\n        // Flag to know if list was already fired\n    fired,\n        // Flag to prevent firing\n    locked,\n        // Actual callback list\n    list = [],\n        // Queue of execution data for repeatable lists\n    queue = [],\n        // Index of currently firing callback (modified by add/remove as needed)\n    firingIndex = -1,\n        // Fire callbacks\n    fire = function () {\n      // Enforce single-firing\n      locked = locked || options.once; // Execute callbacks for all pending executions,\n      // respecting firingIndex overrides and runtime changes\n\n      fired = firing = true;\n\n      for (; queue.length; firingIndex = -1) {\n        memory = queue.shift();\n\n        while (++firingIndex < list.length) {\n          // Run callback and check for early termination\n          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n            // Jump to end and forget the data so .add doesn't re-fire\n            firingIndex = list.length;\n            memory = false;\n          }\n        }\n      } // Forget the data if we're done with it\n\n\n      if (!options.memory) {\n        memory = false;\n      }\n\n      firing = false; // Clean up if we're done firing for good\n\n      if (locked) {\n        // Keep an empty list if we have data for future add calls\n        if (memory) {\n          list = []; // Otherwise, this object is spent\n        } else {\n          list = \"\";\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function () {\n        if (list) {\n          // If we have memory from a past run, we should fire after adding\n          if (memory && !firing) {\n            firingIndex = list.length - 1;\n            queue.push(memory);\n          }\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              if (isFunction(arg)) {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && toType(arg) !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments);\n\n          if (memory && !firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function () {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1); // Handle firing indexes\n\n            if (index <= firingIndex) {\n              firingIndex--;\n            }\n          }\n        });\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function (fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n      },\n      // Remove all callbacks from the list\n      empty: function () {\n        if (list) {\n          list = [];\n        }\n\n        return this;\n      },\n      // Disable .fire and .add\n      // Abort any current/pending executions\n      // Clear all callbacks and values\n      disable: function () {\n        locked = queue = [];\n        list = memory = \"\";\n        return this;\n      },\n      disabled: function () {\n        return !list;\n      },\n      // Disable .fire\n      // Also disable .add unless we have memory (since it would have no effect)\n      // Abort any pending executions\n      lock: function () {\n        locked = queue = [];\n\n        if (!memory && !firing) {\n          list = memory = \"\";\n        }\n\n        return this;\n      },\n      locked: function () {\n        return !!locked;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function (context, args) {\n        if (!locked) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          queue.push(args);\n\n          if (!firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function () {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function () {\n        return !!fired;\n      }\n    };\n\n    return self;\n  };\n\n  return jQuery;\n});","map":{"version":3,"names":["define","jQuery","toType","isFunction","rnothtmlwhite","createOptions","options","object","each","match","_","flag","Callbacks","extend","firing","memory","fired","locked","list","queue","firingIndex","fire","once","length","shift","apply","stopOnFalse","self","add","push","args","arg","unique","has","arguments","remove","index","inArray","splice","fn","empty","disable","disabled","lock","fireWith","context","slice"],"sources":["C:/Users/qimeng/Downloads/Online-Store-main (1)/Online-Store-main/node_modules/jquery/src/callbacks.js"],"sourcesContent":["define( [\n\t\"./core\",\n\t\"./core/toType\",\n\t\"./var/isFunction\",\n\t\"./var/rnothtmlwhite\"\n], function( jQuery, toType, isFunction, rnothtmlwhite ) {\n\n\"use strict\";\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\nreturn jQuery;\n} );\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}